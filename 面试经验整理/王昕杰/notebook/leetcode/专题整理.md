# Leetcode 专题整理
### 位操作
#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        val = 0
        for num in nums:
            val ^= num
        return val
```

#### [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)
```
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了m=3次。找出那个只出现了一次的元素。
```
统计nums数组中二进制1的出现次数,%m,剩下的就是只出现了一次的数字
```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        count = [0 for i in range(32)]
        for num in nums:
            for i in range(32):
                count[i] += num & 1
                num >>= 1
        res = 0
        m = 3
        for i in range(31,-1,-1):
            res <<= 1 # 放在前面避免多左移一次
            res |= count[i] % m
        # 将数字32位以上取反，32位以下不变。
        if count[-1] % m != 0:
            res = ~(res ^ 0xffffffff)
        return res
```
#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)
```python

```
#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)
```
```
```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n = len(nums)
        count = [0 for i in range(32)]
        for num in nums:
            for i in range(32):
                count[i] += num & 1
                num >>= 1
        res = 0
        for i in range(32):
            if count[i] > n/2:
                res |= (1<<i)
        # 将数字32位以上取反，32位以下不变。
        if res >= 1<<31:
            res = ~(res ^ 0xffffffff)
        return res
```

#### [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)
#### [1018. 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/)

## 动态规划
### 背包问题
0-1背包: 416, 474, 494. 背包: 322, 518, 1449.
- 整体框架就是for i 遍历物体, for j 遍历重量维度
- 注意初始化需不需要修改dp
- 01背包在 物体i-1重量j维度 逆序遍历,保证每个物体只使用一次
- 多重背包在 物体i重量j维度 正向遍历,保证物体可以重复使用
**dp二维改一维,还是双重循环,框架不变,只是dp只使用重量j的维度**
#### [简化01背包](https://www.lintcode.com/problem/backpack/description)
```在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]
```
```python
class Solution:
    def backPack(self, m, A):
        # --- 递归
        n = len(A)
        dp = [[0 for i in range(m+1)] for j in range(n+1)]
        def helper(index, curr):
            if index == n:
                dp[index][curr] = curr
                return dp[index][curr]
            if dp[index][curr] > 0:
                return dp[index][curr]
            res = 0
            if curr+A[index] <= m:
                pick = helper(index+1, curr+A[index])
                not_pick = helper(index+1, curr)
                res = max(pick, not_pick)
            else:
                not_pick = helper(index+1, curr)
                res = not_pick
            dp[index][curr] = res
            return res
        return helper(0,0)

        #--- 二维数组
        n, m = len(A)+1, m+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(1, n):
            for j in range(m-1, 0, -1):
                if j < A[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]]+A[i-1])
        # print(dp)
        return dp[-1][-1]

        #--- 一维数组
        n, m = len(A)+1, m+1
        dp = [0] * m
        for i in range(1, n):
            # 01背包逆序,完全背包正序
            for j in range(m, 0, -1):
                if j < A[i-1]:
                    continue
                dp[j] = max(dp[j], dp[j-A[i-1]]+A[i-1])
            # print(dp)
        return dp[-1]
```
#### [经典01背包](https://www.lintcode.com/problem/backpack-ii/description)
```有 n 个物品和一个大小为 m 的背包. 给定数组 A 表示每个物品的大小和数组 V 表示每个物品的价值.
问最多能装入背包的总价值是多大?
```
为什么不能 return value
```python
class Solution:
    def backPackII(self, m, A, V):
        #-- 搜索
        n = len(A)
        dp = [[0 for i in range(m+1)] for j in range(n+1)]
        def helper(index, value, weight):
            if index == n:
                return 0
            if dp[index][weight]:
                return dp[index][weight]
            res = 0
            if weight + A[index] <= m:
                pick = helper(index+1, value, weight+A[index])+V[index]
                not_pick = helper(index+1, value, weight)
                res = max(pick, not_pick)
            else:
                not_pick = helper(index+1, value, weight)
                res = not_pick
            dp[index][weight] = res
            return res

        return helper(0, 0, 0)

        #--- 二维dp
        n, m = len(A)+1, m+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(1, n):
            for j in range(m-1, 0, -1):
                if j < A[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-A[i-1]]+V[i-1])
        return dp[-1][-1]

        #--- 一维dp
        n, m = len(A)+1, m+1
        dp = [0 for i in range(m)]
        for i in range(1, n):
            for j in range(m-1, -1, -1):
                if j < A[i-1]:
                    continue
                else:
                    dp[j] = max(dp[j], dp[j-A[i-1]]+V[i-1])
        return dp[-1]
```
#### [563. 背包问题 V](https://www.lintcode.com/problem/backpack-v/my-submissions)
```给出 n 个物品, 以及一个数组, nums[i] 代表第i个物品的大小, 保证大小均为正数,
正整数 target 表示背包的大小, 找到能填满背包的方案数。每一个物品只能使用一次
```
```python
class Solution:
    """01背包问题,爬楼梯升级版,求排列数
    如果装的下, dp[i][j] = 上一个物品j重量的排列数+上一个物品j-w的排列数
    else      dp[i][j] = 上一个物品j重量的排列数
    """
    def backPackV(self, nums, target):
        # --- 二维dp
        # 1. 初始化dp数组
        n, m = len(nums)+1, target+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(n):
            dp[i][0] = 1
        # 2. 按顺序遍历dp填表
        for i in range(1, n):
            for j in range(1, m):
                # 3. 状态转移方程
                if j - nums[i-1] < 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]
        # print(dp)
        # 4. 最终返回状态
        return dp[-1][-1]

        # --- 一维dp
        dp = [0] * (target+1)
        dp[0] = 1
        n = len(nums)
        for i in range(n):
            for j in range(target, nums[i]-1, -1):
                dp[j] = dp[j-nums[i]] + dp[j]
            print(dp)
        return dp[-1]

        # --- 搜索
        n = len(nums)
        memo = [[0 for i in range(target)] for j in range(n)]
        def helper(index, curr):
            if curr == target:
                return 1
            if curr > target or index == n:
                return 0
            if memo[index][curr]:
                return memo[index][curr]
            pick = helper(index+1, curr+nums[index])
            not_pick = helper(index+1, curr)
            res = pick + not_pick
            memo[index][curr] = res
            return res
        return helper(0, 0)
```
#### [562. 背包问题 IV](https://www.lintcode.com/problem/backpack-iv/description)
```给出 n 个物品, 以及一个数组, nums[i]代表第i个物品的大小, 保证大小均为正数并且没有重复,
正整数 target 表示背包的大小, 找到能填满背包的方案数。每一个物品可以使用无数次
```
#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
```python
class Solution:
    def backPackIV(self, nums, target):
        # 1. 初始化dp
        n = len(nums)+1
        m = target+1
        dp = [[0 for j in range(m)] for i in range(n)]
        for i in range(n):
            dp[i][0] = 1
        # 2. 按规则遍历dp填表
        for i in range(1, n):
            for j in range(1, m):
                # 3. 状态转移
                if j - nums[i-1] < 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] + dp[i][j-nums[i-1]]
        # 4. 输出最终状态
        # for line in dp: print(line)
        return dp[-1][-1]
```

#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
```给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。
```
```python
from collections import deque
import functools
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        """bfs"""
        coins = sorted(coins, reverse=True)
        queue = deque([(amount,0)])
        visited = set([amount])
        while queue:
            top, step = queue.pop()
            if top == 0:
                return step
            for coin in coins:
                res = top - coin
                if res >= 0 and res not in visited:
                    visited.add(res)
                    queue.appendleft((res,step+1))
        return -1

        """dp搜索,记忆化枚举所有状态,对于符合条件返回的状态取最小值"""
        @functools.lru_cache(None)
        def helper(amount):
            if amount == 0:
                return 0
            if amount < 0:
                return None
            res = 0xffffffff
            for coin in coins:
                ans = helper(amount-coin)
                if ans != None:
                    res = min(ans+1, res)
            return res

        ans = helper(amount)
        if ans == 0xffffffff: ans = -1
        return ans

        """dp数组, dp[i]定义为组成金额i所需最少的硬币数"""
        dp = [0xffffffff for i in range(amount+1)]
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin]+1)
        # print(dp)
        return dp[-1] if dp[-1] != 0xffffffff else -1
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)
完全背包问题
70爬楼梯求的是排列数,该题需要求组合数,用递归思路很不直接.因此用dp二维数组,大小(n+1, m+1).
行是coins,列是amount. 初始化dp[i][0]为1,因为amount为0的时候,组合数为1.
然后从上到下,从左到右填表. 状态转移:
1. amount能够使用该硬币,则 dp[i][j] = 使用该硬币组合数+不使用该硬币组合数
2. amount不足以使用该硬币, dp[i][j] = 不使用该硬币组合数
```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        """如果装的下: dp[i][j] = 上一个物品重量j的组合数+该物品重量j-w的组合数
           else:     dp[i][j] = 上一个物品重量j的组合数
           完全背包+该物品重量j-w,因为可以重复使用,01背包+上一个物品重量j-w组合数
           对于滚动数组,完全背包是正向遍历,01背包反向遍历
        """
        # dp = [0] * (amount + 1)
        # dp[0] = 1
        # for coin in coins:
        #     for x in range(coin, amount + 1):
        #         dp[x] = dp[x-coin] + dp[x]
        #     print(dp)
        # return dp[amount]

        n, m = len(coins)+1, amount+1
        dp = [[0 for i in range(m)] for j in range(n)]
        for i in range(n):
            dp[i][0] = 1
        for i in range(1, n):
            for j in range(1, m):
                if j < coins[i-1]:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]
        return dp[-1][-1]
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)
```python
class Solution:
    def climbStairs(self, n: int) -> int:
        ## dp 1维数组
        if n == 1: return 1
        dp = [0] * n
        dp[0] = 1
        dp[1] = 2
        for i in range(2, n):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]

        ## dp 常数
        if n == 1: return 1
        if n == 2: return 2
        prev = 1
        curr = 2
        nxt = 0
        for i in range(2, n):
            nxt = prev + curr
            prev = curr
            curr = nxt
        return nxt

        ## 枚举+记忆
        import functools
        @functools.lru_cache(None)
        def helper(step):
            if step == 0:
                return 1
            if step < 0:
                return 0
            res = 0
            res += helper(step-1)
            res += helper(step-2)
            return res
        return helper(n)
```

#### [77. 组合](https://leetcode-cn.com/problems/combinations/)
```给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
输入: 3, 2  输出: [[1,2],[1,3],[2,3]]
```
1. 每次从上一index+1开始遍历
2. 如果 已选+剩余可选 < k: break
3. results.append()后要return
```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        results = []
        def helper(index, res):
            if len(res) == k:
                results.append(res)
                return # 重要,避免之后无效的递归
            for i in range(index, n+1):
                # 重要,if 已选+剩余可选 < k: break
                if len(res)+n-i+1 < k:
                    break
                helper(i+1, res+[i])
        helper(1, [])
        return results
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)
```给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
输入: nums = [1,2,3]
输出:[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]
```
1. 注意是i+1 不是 index+1
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        results = []
        def helper(index, res):
            if index > n:
                return
            results.append(res)
            for i in range(index, n):
                helper(i+1, res+[nums[i]])
        helper(0, [])
        return results
```

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)
```给定一个 没有重复 数字的序列，返回其所有可能的全排列。
输入: [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
1. 每次都从index为0开始遍历
2. 当前数字不能在已添加数字里
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        results = []
        n = len(nums)
        def helper(res):
            if len(res) == n:
                results.append(res)
                return
            for i in range(0, n):
                if nums[i] not in res:
                    helper(res+[nums[i]])
        helper([])
        return results
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)
```给定一个可包含重复数字的序列，返回所有不重复的全排列。
输入: [1,1,2]   输出: [[1,1,2],[1,2,1],[2,1,1]]
```
```python
from collections import Counter
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        n = len(nums)
        count = Counter(nums)
        results = []
        def helper(res, count):
            if len(res) == n:
                results.append(res)
                return
            for i in range(n):
                # 跳过重复数字
                if i != 0 and nums[i] == nums[i-1]:
                    continue
                # 跳过用尽数字
                if count[nums[i]] == 0:
                    continue
                count[nums[i]] -= 1
                helper(res+[nums[i]], count)
                count[nums[i]] += 1
        helper([], count)
        return results
```


### 二维dp(字符串)
#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
```给定一个字符串 s，找到 s 中最长的回文子串。
输入: "babad" 输出: "bab" 注意: "aba" 也是一个有效答案。
```
从上到下,从左到右
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        """dp[i][j]: 子串s[i,j]是否回文. 2个for循环顺序遍历
        if s[i]==s[j], dp[i][j]=dp[i+1][j-1] or 1(if j-i<3)"""
        n = len(s)
        if n == 0: return ""
        dp = [[0]*n for i in range(n)]
        res = (0, 0)
        for i in range(n):
            dp[i][i] = 1
        for j in range(n):
            for i in range(j):
                if s[i] == s[j]:
                    if j - i < 3:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = dp[i+1][j-1]
                    if dp[i][j] == 1:
                        if j - i > res[1] - res[0]:
                            res = (i, j)
        return s[res[0]: res[1]+1]
```

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)
```给定一个字符串s，找到其中最长的回文子序列，并返回该序列的长度。 输入: "bbbab"  输出: 4
```
```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        """ dp[i][j]: s[i:j]最长的回文子序列长度
        注意i反向遍历(n-1,-1,-1), j正向遍历(i+1, n) """
        n = len(s)
        if n == 0: return 0
        dp = [[0]*n for i in range(n)]
        for i in range(n):
            dp[i][i] = 1
        for i in range(n-1, -1, -1):
            for j in range(i+1, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return dp[0][-1]
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)
```给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列.
```
```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        """ dp[i][j] s1[:i],s2[:j]最长公共子序列
        dp长度为(n1+1,n2+1) 因为要向i-1,j-1查询
        不需要初始化因为初始最长公共子序列为0 """
        n1, n2 = len(text1)+1, len(text2)+1
        dp = [[0]*n2 for i in range(n1)]
        for i in range(1, n1):
            for j in range(1, n2):
                if text1[i-1] == text2[j-1]:
                    dp[i][j] = max(dp[i-1][j-1]+1, dp[i][j-1], dp[i-1][j])
                else:
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j])
        return dp[-1][-1]

        # 求公共子序列元素,倒序遍历,通过dp控制双指针移动
        p1, p2 = n1-2, n2-2
        s = ""
        while p1 >= 0 and p2 >= 0:
            if text1[p1] == text2[p2]:
                s = text1[p1] + s
                p1 -= 1
                p2 -= 1
            else:
                if dp[p1+1][p2] < dp[p1][p2+1]:
                    p1 -= 1
                else:
                    p2 -= 1
        print(s)
```

#### [求最长公共子串的长度和该子串](https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602)
```python
class LongestSubstring:
    def findLongest(self, A, n, B, m):
        dp = [[0]*(m+1) for i in range(n+1)]
        ans = 0
        for i in range(1, n+1):
            for j in range(1, m+1):
                if A[i-1] == B[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                    ans = max(ans, dp[i][j])
                else:
                    dp[i][j] = 0
        return ans
```


#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)
```给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数
你可以对一个单词： 插入一个字符 删除一个字符
输入：word1 = "horse", word2 = "ros"  输出：3
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```
```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        n, m = len(word1)+1, len(word2)+1
        dp = [[0] * m for i in range(n)]
        # 注意初始化空串到另一字符串的距离
        for i in range(n):
            dp[i][0] = i
        for j in range(m):
            dp[0][j] = j
        for i in range(1, n):
            for j in range(1, m):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
        return dp[-1][-1]
```

#### [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)
递归中枚举所有情况,加上记忆化
```python
import functools
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        @functools.lru_cache(None)
        def helper(text, pattern):
            if len(pattern) == 0: return text == ""
            match =  len(text) != 0 and (pattern[0] == text[0] or pattern[0] == ".")
            if len(pattern) > 1 and pattern[1] == "*":
                return helper(text, pattern[2:]) or (match and helper(text[1:], pattern))
            return match and helper(text[1:], pattern[1:])
        return helper(s, p)
```

### 最大子序问题
1. 定义状态
2. 推导状态转移方程
3. 初始化
4. 输出

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)
```给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
输入: [2,3,-2,4]  输出: 6
```
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """
        dp[i][0]: 到数组index为i的元素,最近一段连续的最小乘积
        dp[i][1]: 到数组index为i的元素,最近一段连续的最大乘积
        """
        n = len(nums)
        # 注意２在里面，ｎ在外面
        dp = [[0 for i in range(2)] for j in range(n)]
        # 初始化
        if n == 0: return None
        dp[0][0], dp[0][1] = nums[0], nums[0]
        res = nums[0]
        for i in range(1, n):
            # nums[i] 为正负 两种情况下状态的改变
            if nums[i] > 0:
                # min 的意思为可以在这里截断，dp[i-1]维护的是上一段连续乘积
                dp[i][0] = min(dp[i-1][0]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][1]*nums[i], nums[i])
            else:
                # 最大值变为最小值，最小值变为最大值
                dp[i][0] = min(dp[i-1][1]*nums[i], nums[i])
                dp[i][1] = max(dp[i-1][0]*nums[i], nums[i])
            res = max(res, dp[i][1])
        return res
```

滚动变量,空间优化
```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        """ 滚动变量,不能只使用curr,要引入prev
        curr_min: 到数组当前index,最近一段连续的最小乘积
        curr_max: 到数组当前index,最近一段连续的最大乘积
        注意 prev <-> curr 之间的转化
        """
        n = len(nums)
        prev_max, prev_min, res = nums[0], nums[0], nums[0]
        for i in range(1, n):
            if nums[i] > 0:
                curr_min = min(nums[i], prev_min*nums[i])
                curr_max = max(nums[i], prev_max*nums[i])
            else:
                curr_min = min(nums[i], prev_max*nums[i])
                curr_max = max(nums[i], prev_min*nums[i])
            prev_min, prev_max = curr_min, curr_max
            res = max(res, curr_max)
        return res
```

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)
```给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        """
        dp[i]: 到数组i的最近一段最大和
        注意return res 而不是dp[-1]
        """
        n = len(nums)
        dp = [0 for i in range(n)]
        dp[0], res = nums[0], nums[0]
        for i in range(1, n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            res = max(dp[i], res)
        return res
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        comsum, res = nums[0], nums[0]
        n = len(nums)
        for i in range(1, n):
            comsum = max(nums[i], comsum+nums[i])
            res = max(res, comsum)
        return res
```

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
```给定一个无序的整数数组，找到其中最长上升子序列的长度。
输入: [10,9,2,5,3,7,101,18]  输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
O(n^2)动态规划.
- dp[j]定义为到j为止的最长上升子序列长度
- dp初始化为1, 因为非空数组至少1个上升子序列
- val = dp[i]+1 if nums[j]>nums[i]
- val = 1 截断
- dp[j] 取最大的val,在 for i in range(j)的循环中
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0: return 0
        dp = [1] * n
        max_len = 0
        for j in range(n):
            for i in range(j):
                val = dp[i]+1 if nums[i] < nums[j] else 1
                dp[j] = max(dp[j], val)
            max_len = max(max_len, dp[j])
        return max_len
```
```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def low_bound(nums, l, r, target):
            while l < r:
                m = l + (r-l) // 2
                if nums[m] < target:
                    l = m + 1
                else:
                    r = m
            return l

        dp = []
        for num in nums:
            if len(dp) == 0:
                dp.append(num)
                continue
            index = low_bound(dp, 0, len(dp), num)
            if index == len(dp):
                dp.append(num)
            else:
                dp[index] = num
        return len(dp)
```

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)
```如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。
第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
输入: [1,7,4,9,2,5]   输出: 6
解释: 整个序列均为摆动序列。
```
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        """
        up[i]  : 到nums[i]为止最长的上升摆动序列
        down[i]: 到nums[i]为止最长的下降摆动序列
        """
        n = len(nums)
        if n == 0: return 0
        up = [0 for i in range(n)]
        down = [0 for i in range(n)]
        up[0], down[0] = 1, 1
        for i in range(1, n):
            if nums[i] > nums[i-1]:
                up[i] = down[i-1] + 1
                down[i] = down[i-1]
            elif nums[i] < nums[i-1]:
                up[i] = up[i-1]
                down[i] = up[i-1] + 1
            else:
                up[i] = up[i-1]
                down[i] = down[i-1]
        return max(up[-1], down[-1])
```

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        min_price = prices[0]
        max_profit = 0
        for i in range(1, n):
            profit = prices[i] - min_price
            max_profit = max(max_profit, profit)
            min_price = min(min_price, prices[i])
        return max_profit
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        """
        profit0: 状态为手中无股票的最大收益
        profit1: 状态为手中有股票的最大收益
        """
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = - prices[0]
        for i in range(n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, -prices[i])
        return profit0
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        for i in range(1, n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i])
        return profit0
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit00 = 0
        profit01 = -prices[0]
        profit10 = 0
        profit11 = -prices[0]
        for i in range(n):
            profit00 = max(profit00, profit01+prices[i])
            profit01 = max(profit01, -prices[i])
            profit10 = max(profit10, profit11+prices[i])
            profit11 = max(profit11, profit00-prices[i])
        return profit10
```

#### [188. 买卖股票的最佳时机 IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)
```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if n == 0 or k == 0: return 0
        # 如果交易次数>天数,当作无限次交易O(n)处理
        if k >= n:
            profit0 = 0
            profit1 = -prices[0]
            for i in range(n):
                profit0 = max(profit0, profit1+prices[i])
                profit1 = max(profit1, profit0-prices[i])
            return profit0
        profit0 = [0 for i in range(k)]
        profit1 = [-prices[0] for i in range(k)]
        for i in range(1, n):
            profit0[0] = max(profit0[0], profit1[0]+prices[i])
            profit1[0] = max(profit1[0], -prices[i])
            for j in range(1, k):
                profit0[j] = max(profit0[j], profit1[j]+prices[i])
                profit1[j] = max(profit1[j], profit0[j-1]-prices[i])
        return profit0[-1]
```

#### [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```python
class Solution:
    def maxProfit(self, prices: List[int], fee: int) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        # 注意统一状态,fee在profit0_1处减均可,注意前后统一
        profit1 = -prices[0]-fee
        for i in range(1,n):
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, profit0-prices[i]-fee)
        return profit0
```

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = [0 for i in range(n)]
        profit1 = [-prices[0] for i in range(n)]
        for i in range(1, n):
            profit0[i] = max(profit0[i-1], profit1[i-1]+prices[i])
            profit1[i] = max(profit1[i-1], profit0[i-2]-prices[i])
        return profit0[-1]
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        if n == 0: return 0
        profit0 = 0
        profit1 = -prices[0]
        freeze = 0
        for i in range(n):
            # 注意储存的是前一天的状态
            prev = profit0
            profit0 = max(profit0, profit1+prices[i])
            profit1 = max(profit1, freeze-prices[i])
            freeze = prev
        return profit0
```

### 单调栈
Leetcode: 402, 316, 42, 84, 739, 496, 503, 901
#### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)
```
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。
输入: num = "1432219", k = 3  输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```
维护一个删除k次的单调递增栈
```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        n = len(num)
        if k == n: return "0"
        maintain = n - k
        stack = []
        cnt = 0
        for i in range(n):
            val = int(num[i])
            # 把val<stack[-1]判断放在while,避免写break
            while stack and val < stack[-1] and cnt<k:
                    stack.pop()
                    cnt += 1
            if val == 0 and not stack: continue
            stack.append(val)
        ans = "0" if not stack else "".join(map(str, stack[:maintain]))
        return ans
```
#### [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)
```
给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字
。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组
中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。
输入: nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5
输出: [9, 8, 6, 5, 3]
```
```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        """
        从nums1选取m,nums2选取k-m. 遍历i [0,k], 取最大值
        """
        def pick(m, nums):
            stack = []
            n = len(nums)
            t = n-m
            for i in range(n):
                while stack and nums[i]>stack[-1] and t>0:
                    stack.pop()
                    t -= 1
                stack.append(nums[i])
            return stack[:m]

        def merge(nums1, nums2):
            res = []
            p1, p2 = 0, 0
            while p1 < len(nums1) and p2 < len(nums2):
                # 注意,这里一定要用list比较
                if nums1[p1:] < nums2[p2:]:
                    res.append(nums2[p2])
                    p2 += 1
                else:
                    res.append(nums1[p1])
                    p1 += 1
            if p1 == len(nums1):
                res.extend(nums2[p2:])
            elif p2 == len(nums2):
                res.extend(nums1[p1:])
            return res

        max_select = [0 for i in range(k)]
        for i in range(k+1):
            if i > len(nums1) or k-i > len(nums2):
                continue
            select1 = pick(i, nums1)
            select2 = pick(k-i, nums2)
            select = merge(select1, select2)
            max_select = max(max_select, select)
        return max_select
```
#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
基本思路,对每个i,其能装载的水量为, min(left_max, right_max)-curr_h
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """单调栈"""
        stack = []
        waters = 0
        for i in range(len(height)):
            while stack and height[stack[-1]] < height[i]:
                curr_i = stack.pop()
                curr_h = height[curr_i]
                if len(stack) == 0: break
                boundary = min(height[stack[-1]], height[i])
                water = (boundary - curr_h) * (i - stack[-1] - 1)
                waters += water
            stack.append(i)
        return waters
```
```python
class Solution:
    def trap(self, height: List[int]) -> int:
        """动态规划"""
        n = len(height)
        if n==0: return 0
        max_left_height = [0 for i in range(n)]
        max_right_height = [0 for i in range(n)]
        max_left_height[0] = height[0]
        max_right_height[-1] = height[-1]
        for i in range(1,n):
            max_left_height[i] = max(max_left_height[i-1], height[i])
        for i in range(n-2,-1,-1):
            max_right_height[i] = max(max_right_height[i+1], height[i])
        waters = 0
        for i in range(n):
            left_height = max_left_height[i]
            right_height = max_right_height[i]
            curr_height = height[i]
            boundary = min(left_height, right_height)
            water = boundary-curr_height
            waters += water
        return waters
```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
```
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
维护单调递增栈
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        heights = [0] + heights + [0]
        stack = []
        max_area = 0
        for i in range(len(heights)):
            while stack and heights[i] < heights[stack[-1]]:
                index = stack.pop()
                curr_h = heights[index]
                area = curr_h * (i - stack[-1] - 1)
                max_area = max(max_area, area)
            stack.append(i)
        return max_area
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)
1. 维护单调递增的栈
2. 每层统计高度,同时入栈操作
3. 注意height两头有哨兵节点0
4. 注意 area 的宽为 j-stack[-1]-1
```
输入:
 [["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]]
输出: 6
```
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        n = len(matrix)
        if n == 0: return 0
        m = len(matrix[0])
        height = [0] * (m+2)
        max_area = 0
        for i in range(n):
            stack = []
            for j in range(m+2):
                if j < m:
                    if matrix[i][j] == "1":
                        height[j+1] += 1
                    else:
                        height[j+1] = 0
                while stack and height[j] < height[stack[-1]]:
                    index = stack.pop()
                    curr_h = height[index]
                    area = curr_h * (j - stack[-1] - 1)
                    max_area = max(area, max_area)
                stack.append(j)
        return max_area
```

#### [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)
```
给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。
nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
```
```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        """基于nums2构造单调递减栈,构造hashmap"""
        stack = []
        mapping = {}
        for i in range(len(nums2)):
            while stack and nums2[i] > stack[-1]:
                val = stack.pop()
                mapping[val] = nums2[i]
            stack.append(nums2[i])

        result = [-1 for i in range(len(nums1))]
        for i, num in enumerate(nums1):
            if num in mapping:
                result[i] = mapping[num]
        return result
```
#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        stack = []
        n0 = len(nums)
        result = [-1 for i in range(n0)]
        nums = nums * 2
        for i, num in enumerate(nums):
            while stack and num > nums[stack[-1]]:
                index = stack.pop()
                if index < n0:
                    result[index] = num
            stack.append(i)
        return result
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)
```
根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```
```python
class Solution:
    def dailyTemperatures(self, T: List[int]) -> List[int]:
        stack = []
        n = len(T)
        results = [0 for i in range(n)]
        for i in range(n):
            while stack and T[i] > T[stack[-1]]:
                index = stack.pop()
                results[index] = i - index
            stack.append(i)
        return results
```

#### [901. 股票价格跨度](https://leetcode-cn.com/problems/online-stock-span/)
```python
class StockSpanner:
    def __init__(self):
        self.stack = []
        self.result = []
        self.cnt = 0
    def next(self, price: int) -> int:
        res = 1
        while self.stack and self.stack[-1][-1] <= price:
            index, pric = self.stack.pop()
            res += self.result[index]
        self.result.append(res)
        self.stack.append((self.cnt, price))
        self.cnt += 1
        return res
```

### 前缀和
#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
输入:nums = [1,1,1], k = 2  输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        """O(n^2)"""
        # i, j = 0, 1
        # n = len(nums)
        # prefixsum = [0] * (n+1)
        # for i in range(n):
        #     prefixsum[i+1] = prefixsum[i] + nums[i]
        # cnt = 0
        # for i in range(n+1):
        #     for j in range(i+1, n+1):
        #         if prefixsum[j] - prefixsum[i] == k:
        #             cnt += 1
        # return cnt

        """O(n)前缀和 + memo, memo存储"""
        prefix = {0: 1}
        comsum = 0
        cnt = 0
        for num in nums:
            comsum += num
            if comsum - k in prefix:
                cnt += prefix[comsum-k]
            prefix[comsum] = prefix[comsum] + 1 if comsum in prefix else 1
        return cnt
```

#### [523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)
```python
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        """ 前缀和存储 {前缀和%k:index}
        如果当前前缀和%k出现过prefix中,说明区间和%k为0,再判断长度>=2
        注意如果该前缀和%k已经出现过,则不更新prefix"""
        comsum = 0
        prefix = {0: -1}
        for i, num in enumerate(nums):
            comsum += num
            if k != 0:
                comsum %= k
            if comsum in prefix:
                if i - prefix[comsum] >= 2:
                    return True
            else:
                prefix[comsum] = i
        return False
```

#### [1477. 找两个和为目标值且不重叠的子数组](https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/)
```
给你一个整数数组 arr 和一个整数值 target 。
请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。
请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。
输入：arr = [3,1,1,1,5,1,2,1], target = 3  输出：3
解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。
```
```python
class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        """前缀和,动态规划. dp[i]:到i处满足条件的最短的长度.
        思路: 构建dict{前缀和:index},如果存在,查询满足条件的当前长度,
        更新dp[i] = min(dp[i-1], curr), 如果dp[prev_index]存在, res=min(res, curr+dp[prev_index])
        """
        prefix = {0: -1} # becareful
        n = len(arr)
        dp = [float("inf")] * n
        comsum = 0
        res = float("inf")
        for i in range(n):
            comsum += arr[i]
            prefix[comsum] = i
            if comsum-target in prefix:
                prev_index = prefix[comsum-target]
                curr = i - prev_index
                dp[i] = min(dp[i-1], curr)
                if dp[prev_index] != float("inf") and prev_index > -1:
                    res = min(res, curr+dp[prev_index])
            else:
                dp[i] = dp[i-1]
        return res if res != float("inf") else -1
```

#### [1300. 转变数组后最接近目标值的数组和](https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/)
```
给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。
如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。
输入：arr = [4,9,3], target = 10   输出：3
解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。
```
思路: 先排序,再遍历arr. 每次计算 当前到尾部元素的平均值,如果这个平均值<=当前元素,说明可以把之后的元素都变成当前元素,否则跳过
具体return的时候注意5舍6入.
```python
class Solution:
    def findBestValue(self, arr: List[int], target: int) -> int:
        arr.sort()
        presum = 0
        n = len(arr)
        for i in range(n):
            x = (target - presum) // (n - i)
            if x <= arr[i]:
                t = (target - presum) / (n - i)
                if t - x <= 0.5:
                    return x
                else:
                    return x+1
            presum += arr[i]
        return arr[-1]
```

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)
```
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
输入：A = [4,5,0,-2,-3,1], K = 5  输出：7
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```
```python
class Solution:
    def subarraysDivByK(self, A: List[int], K: int) -> int:
        n = len(A)
        total, ans = 0, 0
        memo = {0:1}
        for num in A:
            total += num
            res = total % K
            temp = memo.get(res, 0)
            ans += temp
            memo[res] = temp + 1
        return ans
```

#### [1248. 统计优美子数组](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
```
给你一个整数数组 nums 和一个整数 k。如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。请返回这个数组中「优美子数组」的数目。
输入：nums = [1,1,2,1,1], k = 3  输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
```
```python
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        # odd_positions = [0]  # 设定一个数组记录奇数的位置，0代表当前位置之前的一个奇数的位置(fake point)
        # for i in range(len(nums)):
        #     if nums[i] % 2 == 1:
        #         odd_positions.append(i + 1)  # 将位置压入
        # odd_positions.append(len(nums) + 1)  # len(nums)+1代表最后一个奇数位之后的奇数位置(fake point)
        # count = 0
        # for i in range(1, len(odd_positions) - k):
        #     # 当前奇数位置 i 到前一个奇数位置之间选一个位置 * i 后的第 k-1 个奇数的位置到 i 后的第 k 个奇数节点范围内选一个
        #     count += ((odd_positions[i] - odd_positions[i - 1]) *
        #               (odd_positions[i + k] - odd_positions[i + k - 1]))  # 组合数
        # return count

        """
        pre_fix: 到当前index累计奇数的个数
        pre_fix_count: 记录每个奇数个数下的不同的连续数组个数
        """
        pre_fix_count = [1] + [0] * len(nums)
        pre_fix = 0
        result = 0
        for i in range(len(nums)):
            odd = 1 if nums[i] % 2 == 1 else 0
            pre_fix += odd
            pre_fix_count[pre_fix] += 1
            if pre_fix >= k:
                result += pre_fix_count[pre_fix - k]
        return result
```


#### [1371. 每个元音包含偶数次的最长子字符串](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/)
TODO: 再理解一下
```python
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        res = 0
        state = [-1] * (1 << 5)
        cur, state[0] = 0, 0
        d = dict(zip('aeiou', range(5)))
        for idx, val in enumerate(s):
            tmp = -1
            if val in d:
                tmp = d[val]
            if tmp != -1:
                cur ^= 1 << tmp
            if state[cur] == -1:
                state[cur] = idx + 1
            else:
                res = max(res, idx + 1 - state[cur])
        return res
```

### 树
#### 建树
##### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left >= right: return None
            mid = left + (right-left)//2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid)
            root.right = helper(mid+1, right)
            return root
        return helper(0, len(nums))
```

##### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/) [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        n = len(preorder)
        # 建立哈希表，实现O(1)查询
        lookup_table = {inorder[i]: i for i in range(n)}
        # 递归中维护子树根index与子树区间范围(相对于preorder)
        def helper(root_i, left, right):
            # 如果区间相交，return叶子节点的None
            if left >= right: return
            root = TreeNode(preorder[root_i])
            # 查询子树根在中序遍历中的位置
            in_i = lookup_table[preorder[root_i]]
            # 左子树root index 根+1
            root.left = helper(root_i+1, left, in_i)
            # 右子树root index 根+左子树长度+1
            root.right = helper(root_i+in_i-left+1, in_i+1, right)
            # 层层向上返回子树的根
            return root

        root = helper(0, 0, n)
        return root
```


### 滑动窗口
#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
维护两个窗口window_s, window_t, 一个变量curr. 当window_s覆盖了window_t, 移动左指针.
实现时, 用变量curr, 突破与下降临界时curr变动, 复杂度从用isvalid的O(n^2)降到O(n)
```python
from collections import Counter, defaultdict
class Solution:
    def isvalid(self, dict1, dict2):
        valid = True
        for key in dict1:
            if key in dict2 and dict1[key] <= dict2[key]:
                continue
            else:
                valid = False
                break
        return valid

    def minWindow(self, s: str, t: str) -> str:
        l, r = 0, 0
        window_s = defaultdict(int)
        window_t = Counter(t)
        require = len(window_t)
        curr = 0

        min_l, min_r, min_len = 0, 0, float("inf")
        while r < len(s):
            window_s[s[r]] += 1
            if window_s[s[r]] == window_t[s[r]]:
                curr += 1

            while l<=r and curr == require:
                if r-l+1 < min_len:
                    min_len = r-l+1
                    min_l = l
                    min_r = r
                if window_s[s[l]] == window_t[s[l]]:
                    curr -= 1
                window_s[s[l]] -= 1
                l += 1
            r += 1
        ans = s[min_l:min_r+1] if min_len != float("inf") else ""
        return ans
```
#### [3.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l = 0
        n = len(s)
        window = set()
        max_len = 0
        for r in range(n):
            if s[r] not in window:
                window.add(s[r])
                max_len = max(max_len, r-l+1)
            else:
                while s[r] in window:
                    window.remove(s[l])
                    l += 1
                window.add(s[r])
        return max_len
```
#### [30.串联所有单词的子串](https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/)
TODO
```python
from collections import Counter
class Solution:
    def isvalid(self, window):
        for val in window.values():
            if val > 0: return False
        return True

    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        if not s or not words: return []
        n = len(words)
        m = len(words[0])
        window0 = Counter(words)
        p = 0
        results = []
        for i in range(len(s)-n*m+1):
            p = i
            window = window0.copy()
            while p+m <= len(s) and s[p:p+m] in window and window[s[p:p+m]]>0:
                window[s[p:p+m]] -= 1
                p += m
                if self.isvalid(window):
                    results.append(i)
        return results
```
#### [76.最小覆盖子串](https://leetcode-cn.com/problems/longest-common-prefix/)
```python
from collections import Counter
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        """
        1. 右指针逐步向前移动,满足条件后停下
        2. 左指针逐步向前收缩,不满足条件后停下,先记录最后满足条件的答案,再向前一步进入不满足状态
        3. 循环1,2, 过程中记录所有满足条件的最小值, return时如果没有被更新过, return ""
        """
        count = Counter(t)
        cnt = len(count)
        n = len(s)
        l = 0
        res = (0, n+1)
        for r in range(n):
            if s[r] in count:
                count[s[r]] -= 1
                if count[s[r]] == 0:
                    cnt -= 1
                while cnt == 0:
                    if s[l] in count:
                        count[s[l]] += 1
                        if count[s[l]] == 1:
                            cnt += 1
                            count[s[l]]
                            if r - l < res[1] - res[0]:
                                res = (l, r)
                    l += 1
        return s[res[0]:res[1]+1] if res != (0, n+1) else ""  
```

#### [567.字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
这一题如果前向遍历就超时. 双指针的核心就是O(2n)遍历所有可能性,在最后一个满足的情况判断
```python
from collections import Counter
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        m, n = len(s1), len(s2)
        l = 0
        window = Counter(s1)
        cnt = len(window)
        for r in range(n):
            if s2[r] in window:
                window[s2[r]] -= 1
                if window[s2[r]] == 0:
                    cnt -= 1
            while cnt == 0:
                if s2[l] in window:
                    window[s2[l]] += 1
                    if window[s2[l]] == 1:
                        cnt += 1
                        # 最后一个满足的情况是不是==len(s1)
                        if r-l+1 == m:
                            return True
                l += 1
        return False

        """超时"""
        # window = Counter(s1)
        # cnt = len(window)
        # if cnt == 0: return True
        # n, m = len(s2), len(s1)
        # for l in range(n):
        #     if s2[l] in window:
        #         if l + m > n:
        #             return False
        #         _window = window.copy()
        #         for r in range(l, l+m):
        #             if s2[r] in _window:
        #                 _window[s2[r]] -= 1
        #                 if _window[s2[r]] == 0:
        #                     cnt -= 1
        #                     if cnt == 0:
        #                         return True
        #             else:
        #                 break
        #         cnt = len(window)
        # return False
```

#### [209.长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)
```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        i = 0
        comsum = 0
        res = (0, float("inf"))
        for j in range(len(nums)):
            comsum += nums[j]
            while comsum >= s:
                if j-i < res[1]-res[0]:
                    res = (i, j)
                comsum -= nums[i]
                i += 1
        minlen = res[1] - res[0] + 1
        return minlen if minlen < float("inf") else 0
```
#### [239.滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        """维护单调递减的双端队列, 存储的是index"""
        queue = deque()
        results = []
        for i, num in enumerate(nums):
            # pop 离开左侧窗口的index
            while queue and queue[0] <= i-k:
                queue.popleft()
            # 维护单调递减
            while queue and num > nums[queue[-1]]:
                queue.pop()
            queue.append(i)
            if i >= k-1:
                results.append(nums[queue[0]])
        return results
```

#### [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)
```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        n1, n2 = len(num1), len(num2)
        n = max(n1, n2)
        carry = 0
        p = 0
        res = ""
        while carry or p < n:
            val1 = int(num1[-(p+1)]) if p < n1 else 0
            val2 = int(num2[-(p+1)]) if p < n2 else 0
            carry, val = divmod(val1+val2+carry, 10)
            res = str(val) + res
            p += 1
        return res
```

#### [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)
```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        n1, n2 = len(num1), len(num2)
        res = [0] * (n1+n2)
        for i in range(n1-1, -1, -1):
            for j in range(n2-1, -1, -1):
                val = res[i+j+1] + int(num1[i]) * int(num2[j])
                res[i+j] += val // 10 # 十数位加进位
                res[i+j+1] = val % 10 # 个数位取mod
        # 去除前置0
        for i in range(len(res)):
            if res[i] != 0:
                return "".join(map(str, res[i:]))
        return "0"
```
#### [632.最小区间]
TODO

### 线段树
#### [307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)
```python
class NumArray(object):
    """
    1. 线段树总长度2n, index 0 处留空(前n-1个是汇总节点，后n个叶子节点)
    2. 父节点i, 左节点2*i(偶数), 右节点2*i+1(奇数)
    """
    def __init__(self, nums):
        """建树O(n), 空间O(2n)"""
        self.lenth = len(nums)
        self.tree = [0] * self.lenth + nums
        for i in range(self.lenth-1, 0, -1):
            # 父节点 = 左子节点 + 右子节点 (奇偶均适用)
            self.tree[i] = self.tree[i<<1] + self.tree[i<<1|1]

    def update(self, i, val):
        """更新O(logn)"""
        n = self.lenth + i
        self.tree[n] = val
        while n > 1:
            # 父节点 = 更新节点 + 更新节点的相邻节点
            self.tree[n>>1] = self.tree[n] + self.tree[n^1]
            n >>= 1

    def sumRange(self, i, j):
        """查询O(logn)"""
        i, j = self.lenth+i, self.lenth+j
        res = 0
        while i <= j:
            # 如果查询左边界是右子节点跳过其父节点直接加上
            if i & 1 == 1:
                res += self.tree[i]
                i += 1
            i >>= 1
            # 如果查询右边界是左子节点跳过其父节点直接加上
            if j & 1 == 0:
                res += self.tree[j]
                j -= 1
            j >>= 1
        return res
```
#### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)
```python
class SegmentTree:
    def __init__(self, nums):
        self.lenth = len(nums)
        self.tree = [0] * self.lenth + nums

    def update(self, i):
        n = self.lenth + i
        self.tree[n] += 1
        while n > 1:
            self.tree[n>>1] = self.tree[n] + self.tree[n^1]
            n >>= 1

    def query(self, i, j):
        i, j = self.lenth+i, self.lenth+j
        res = 0
        while i <= j:
            if i & 1 == 1:
                res += self.tree[i]
                i += 1
            i >>= 1
            if j & 1 == 0:
                res += self.tree[j]
                j -= 1
            j >>= 1
        return res

class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        """建立一个哈希表，查询排名，
        维护一个长度为n'的线段树,从后往前遍历,每次排名的索引处值+1，
        查询[0,排名-1]区间的值就是右侧小于当前元素的个数"""
        if len(nums) == 0: return []
        uni_nums = list(set(nums))
        uni_nums.sort()
        tree = SegmentTree([0]*len(uni_nums))
        lookup = {}
        for i in range(len(uni_nums)):
            lookup[uni_nums[i]] = i
        results = [0] * len(nums)
        for i in range(len(nums)-1, -1, -1):
            rank = lookup[nums[i]]
            ans = tree.query(0, rank-1)
            tree.update(rank)
            results[i] = ans
        return results
```

### 并查集
#### [990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)
典型并查集
```python
class UnionFindSet:
    def __init__(self, n):
        self.parent = [i for i in range(n)]
        self.rank = [0] * n

    def find(self, x):
        """返回根节点的同时完全压缩"""
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        """合并两个节点到同一根节点,并维护rank"""
        px, py = self.find(x), self.find(y)
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[px] = py
            self.rank[py] += 1

    def is_connect(self, x, y):
        """查询两个节点是否联通"""
        return self.find(x) == self.find(y)

class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        unionfind = UnionFindSet(26)
        for item in equations:
            if item[1] == "=":
                index1 = ord(item[0]) - ord("a")
                index2 = ord(item[3]) - ord("a")
                unionfind.union(index1, index2)
        for item in equations:
            if item[1] == "!":
                index1 = ord(item[0]) - ord("a")
                index2 = ord(item[3]) - ord("a")
                if unionfind.is_connect(index1, index2):
                    return False
        return True
```

#### [547. 朋友圈](https://leetcode-cn.com/problems/friend-circles/)
最终 return self.parent 不同的节点数是错误的解法
因此维护self.cnt变量,union操作时,如果父节点相同,不操作,父节点不相同,合并子数,cnt-1
```python
class UnionFindSet():
    def __init__(self, size):
        self.parent = [i for i in range(size)]
        self.rank = [0] * size
        self.cnt = size

    def find(self, x):
        if x != self.parent[x]:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return
        self.cnt -= 1
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[px] = py
            self.rank[py] += 1

class Solution:
    def findCircleNum(self, M: List[List[int]]) -> int:
        n = len(M)
        unionfind = UnionFindSet(n)
        for i in range(n):
            for j in range(i):
                if M[i][j] == 1:
                    unionfind.union(i, j)
        return unionfind.cnt
```

### 拓扑排序
#### 同时完成项目的最短时间
参考: https://www.youtube.com/watch?v=x3mm5a_CwRM
```python
times = [2,2,4,2,3,6,1]
depends = [[0,1],[0,2],[1,3],[2,3],[3,4],[5,6],[6,4]]

from collections import defaultdict, deque
if __name__ == "__main__":
    n = len(times)
    indegrees = [0] * n
    adjacency = defaultdict(list)
    for depend in depends:
        prev, curr = depend
        adjacency[prev].append(curr)
        indegrees[curr] += 1

    queue = deque()
    earliest = [0] * n
    latest = [float("inf")] * n
    for i in range(n):
        if indegrees[i] == 0:
            queue.append(i)
            earliest[i] = times[i]
    queue0 = queue.copy()

    """ O(V+E) """
    while queue:
        prev = queue.pop()
        if prev not in adjacency:
            continue
        for curr in adjacency[prev]:
            indegrees[curr] -= 1
            earliest[curr] = max(earliest[curr], earliest[prev]+times[curr])
            if indegrees[curr] == 0:
                queue.appendleft(curr)
    print(earliest)

    """假如还要反向推回去求机动时间"""
    rev_adjacency = [[] for i in range(n)]
    for depend in depends:
        prev, curr = depend
        rev_adjacency[curr].append(prev)

    queue = deque()
    max_val = max(earliest)
    latest = [max_val] * n
    for i in range(n):
        if earliest[i] == max_val:
            queue.append(i)

    while queue:
        curr = queue.pop()
        for prev in rev_adjacency[curr]:
            queue.appendleft(prev)
            latest[prev] = min(latest[prev], latest[curr]-times[curr])
    print(latest)

    """机动时间定义为 earliest[i]-latest[j]-V[i][j], 机动时间为0的活动组成的路径称为关键路径"""
    queue = queue0
    flexible = [[0] * n for i in range(n)]
    while queue:
        prev = queue.pop()
        if prev not in adjacency:
            continue
        for curr in adjacency[prev]:
            flexible[prev][curr] = latest[curr] - earliest[prev] - times[curr]
            queue.appendleft(curr)
    print(flexible)
```

## 链表
### 反转链表
#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt
        return prev
```
#### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

#### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        """利用 stack LIFO 的性质反转链表"""
        dummy = dummyhead = ListNode(-1)
        node = head
        while True:
            cnt = k
            stack = []
            temp = node
            # 把k个节点加入stack
            while cnt > 0 and node:
                cnt -= 1
                stack.append(node)
                node = node.next
            # 如果不满k个, 不反转
            if cnt != 0:
                dummy.next = temp
                break
            while stack:
                dummy.next = stack.pop()
                dummy = dummy.next
            # 避免死循环
            dummy.next = None
        return dummyhead.next
```
